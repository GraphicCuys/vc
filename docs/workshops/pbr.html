<!DOCTYPE html><html><head><title>vc | PBR (Physically Based Rendering) - Como Obtener Materiales Realistas para Rasterización y Ray Tracing</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><meta name="robots" content="index,follow"><meta name="theme-color" content="#212121"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link href="https://fonts.googleapis.com/css?family=Hind:400,700&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:300,400&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/icon?family=Material+Icons%7CMaterial+Icons+Outlined&amp;display=swap" rel="stylesheet"><style>
      body, input, button {
        font-family: 'Hind', sans-serif;
      }

      code, .hljs {
        font-family: 'Source Code Pro', 'Courier New', Courier, monospace;
      }

      .icon-font {
        font-family: 'Material Icons';
        font-weight: normal;
        font-style: normal;
        font-size: 24px;  /* Preferred icon size */
        display: inline-block;
        line-height: 1;
        text-transform: none;
        letter-spacing: normal;
        word-wrap: normal;
        white-space: nowrap;
        direction: ltr;
      
        /* Support for all WebKit browsers. */
        -webkit-font-smoothing: antialiased;
        /* Support for Safari and Chrome. */
        text-rendering: optimizeLegibility;
      
        /* Support for Firefox. */
        -moz-osx-font-smoothing: grayscale;
      
        /* Support for IE. */
        font-feature-settings: 'liga';
      }

      .icon-font.outline {
        font-family: 'Material Icons Outlined';
      }
    </style><link href="/vc/docs/assets/codedoc-styles.css" rel="stylesheet"><script async="" defer="" src="/vc/docs/assets/codedoc-bundle.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"></head><body><div class="header-0-0-11"><script async="" defer="" src="https://buttons.github.io/buttons.js"></script><a class="github-button" data-color-scheme="no-preference: light; light: light; dark: dark;" data-icon="octicon-star" data-show-count="false" data-size="large" href="https://github.com/graphiccuys/vc/">Star</a><br><br><a class="watermark-0-0-10" href="https://github.com/CONNECT-platform/codedoc" target="_blank">Created With<svg viewBox="0 0 536 296" version="1.1" xmlns="http://www.w3.org/2000/svg"><g id="codedoc" transform="translate(-244.000000, -364.000000)" fill-rule="nonzero"><path d="M580,532 C615.346224,532 644,560.653776 644,596 C644,631.346224 615.346224,660 580,660 C544.653776,660 516,631.346224 516,596 C516,560.653776 544.653776,532 580,532 Z M716,532 C751.346224,532 780,560.653776 780,596 C780,631.346224 751.346224,660 716,660 L692,660 C687.581722,660 684,656.418278 684,652 C684,647.581722 687.581722,644 692,644 L716,644 C742.509668,644 764,622.509668 764,596 C764,569.490332 742.509668,548 716,548 L692,548 C687.581722,548 684,544.418278 684,540 C684,535.581722 687.581722,532 692,532 L716,532 Z M468,532 C472.418278,532 476,535.581722 476,540 L476,652 C476,656.418278 472.418278,660 468,660 L444,660 C408.653776,660 380,631.346224 380,596 C380,560.653776 408.653776,532 444,532 L468,532 Z M332,532 C336.418278,532 340,535.581722 340,540 L340,652 C340,656.418278 336.418278,660 332,660 L252,660 C247.581722,660 244,656.418278 244,652 L244,540 C244,535.581722 247.581722,532 252,532 L332,532 Z M580,548 C553.490332,548 532,569.490332 532,596 C532,622.509668 553.490332,644 580,644 C606.509668,644 628,622.509668 628,596 C628,569.490332 606.509668,548 580,548 Z M461,548 L444,548 C417.490332,548 396,569.490332 396,596 C396,622.509668 417.490332,644 444,644 L461,644 L461,548 Z M444,364 C479.346224,364 508,392.653776 508,428 C508,463.346224 479.346224,492 444,492 C408.653776,492 380,463.346224 380,428 C380,392.653776 408.653776,364 444,364 Z M332,364 C336.418278,364 340,367.581722 340,372 C340,376.418278 336.418278,380 332,380 L308,380 C281.490332,380 260,401.490332 260,428 C260,454.509668 281.490332,476 308,476 L332,476 C336.418278,476 340,479.581722 340,484 C340,488.418278 336.418278,492 332,492 L308,492 C272.653776,492 244,463.346224 244,428 C244,392.653776 272.653776,364 308,364 L332,364 Z M580,364 C615.346224,364 644,392.653776 644,428 C644,463.346224 615.346224,492 580,492 L556,492 C551.581722,492 548,488.418278 548,484 L548,372 C548,367.581722 551.581722,364 556,364 L580,364 Z M772,364 C776.418278,364 780,367.581722 780,372 C780,376.418278 776.418278,380 772,380 L700,380 L700,420 L772,420 C776.418278,420 780,423.581722 780,428 C780,432.418278 776.418278,436 772,436 L700,436 L700,476 L772,476 C776.418278,476 780,479.581722 780,484 C780,488.418278 776.418278,492 772,492 L692,492 C687.581722,492 684,488.418278 684,484 L684,372 C684,367.581722 687.581722,364 692,364 L772,364 Z M444,380 C417.490332,380 396,401.490332 396,428 C396,454.509668 417.490332,476 444,476 C470.509668,476 492,454.509668 492,428 C492,401.490332 470.509668,380 444,380 Z M580,380 L563,380 L563,476 L580,476 C606.509668,476 628,454.509668 628,428 C628,401.490332 606.509668,380 580,380 Z"></path></g></svg></a></div><div id="-codedoc-container" class="container"><h1 id="pbr-physically-based-rendering---como-obtener-materiales-realistas-para-rasterización-y-ray-tracing" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>PBR (Physically Based Rendering) - Como Obtener Materiales Realistas para Rasterización y Ray Tracing</h1><h2 id="de-donde-nacen-los-shaders-pbr" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>De donde Nacen los Shaders PBR</h2><p>En el mundo de las gráficas por computador los algoritmos de renderización basados en ray tracing para iluminación global generan los resultados más fotorrealistas gracias a su simulación de las propiedades físicas de la luz, sin embargo estos son computacionalmente pesados y difíciles de implementar en tiempo real sin el apoyo de hardware gráfico especializado, es por esto que los desarrolladores que trabajan en estos algoritmos tratan de hacer lo posible por optimizar los cálculos requeridos para su implementación sin comprometer el fotorrealismo de la imagen. Por el otro lado existen los algoritmos basados en rasterización que no hacen uso de la iluminación global y están basados en la proyección que los objetos tridimensionales generan en la pantalla, estos pueden producir imágenes en tiempo real ya que no son tan pesados pero su acercamiento al fotorrealismo no es ideal y los desarrolladores que trabajan con estos tratan de aumentar su complejidad para obtener materiales más realistas.</p><p>Hoy en día se utilizan una gran cantidad de implementaciones de estos algoritmos en diferentes software como motores de videojuegos, programas de manipulación de gráficos 3D entre otros para producir imágenes generadas por computador, el problema durante mucho tiempo era que cada una de estas implementaciones utilizaban sus propias formas de definir shaders que en muchos casos no eran compatibles entre ellas. Todos estos problemas han llevado a avances en la estandarización de shaders que buscan definir materiales de objetos utilizando como inputs archivos que fueran fácilmente exportables e implementables en diferentes programas (generalmente imágenes), que pudieran ser aplicables tanto en renderizadores que manejen ray tracing, rasterización o combinaciones híbridas de ambas técnicas y que trataran de imitar lo más posible el comportamiento físico de la luz con objetos reales para generar materiales físicos y realistas.</p><h2 id="que-es-pbr-y-como-se-definen-sus-inputs" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Que es PBR y como se Definen sus Inputs</h2><p>Teóricamente el Physical en Physically Based Rendering proviene de simular y abstraer computacionalmente el comportamiento físico que la luz describe al interactuar sobre diferentes materiales, los rayos de luz viajan a través del espacio hasta encontrarse con un objeto en su camino, una vez interactúan con el objeto estos rayos pueden ser reflejados o absorbidos por el material dependiendo de su composición. Los rayos absorbidos no contribuyen nada al color del material, sin embargo los rayos reflejados definirán su color y dependiendo de su comportamiento (dirección, rebote, incidencia, ángulo) al ser reflejado por el material presentarán ciertas propiedades que definirán su apariencia ante nuestros ojos.</p><p>Aunque algunas definiciones de shaders PBR cambian según su implementación la base teórica de estos se maneja bajo una serie de “canales” que definen las propiedades de un material de una manera realista, lo ideal sería tener un shader por cada material que se va a utilizar pero en la realidad y en la práctica cualquier objeto puede estar conformado por varios materiales y componentes, esto requiere que diferentes propiedades puedan ser descritas y modificadas en el mismo archivo y es por esto que en general todas estas propiedades se definen como texturas mapeadas al objeto para cada uno de los canales que se describen a continuación.</p><ul><li><h3 id="canal-de-color---albedo--diffuse" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Canal de Color - Albedo / Diffuse</h3><p>Los rayos de luz visible se componen de un espectro de colores y según el tipo de material con el que la luz interactúa algunos de estos colores serán absorbidos mientras que otros serán reflejados en múltiples direcciones, en el objeto esta reflexión se conoce como reflexión difusa y la combinación de colores de los rayos difusos determinan el “color base” del objeto. 
<img src="/vc/docs/sketches/diffuse.png" alt="Diffuse Theory">
Imagen__&gt;:<a href="https://academy.substance3d.com/courses/the-pbr-guide-part-1">https://academy.substance3d.com/courses/the-pbr-guide-part-1</a></p><p>  Como input para un shader PBR se define este color base o se asigna una textura llamada diffuse o albedo que representa el color del objeto, dependiendo de la implementación esta textura puede contener detalles, sombras e imperfecciones para hacerlo más realista sin embargo es común que esta textura solamente contenga la información de color base. </p><p>  <img src="/vc/docs/sketches/img-diffuse.png" alt="Diffuse Implementation"></p></li></ul><ul><li><h3 id="canal-de-rugosidad---roughness--specular" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Canal de Rugosidad - Roughness / Specular</h3><p>Ningún material en la vida real es 100% plano ya que a nivel microscópico existen imperfecciones que afectan la dirección en que la luz es reflejada, entre más plano sea un objeto la luz será absorbida o redireccionada menos creando cada vez más una reflexión exacta de la luz que entra al material en dirección perpendicular a la que entró, en el objeto esta reflexión se conoce como reflexión especular siendo un espejo la máxima expresión de este fenómeno, en el otro extremo materiales con muchas imperfecciones microscópicas tienden a no reflejar la luz en la misma dirección y tienen una presentación mucho menos reflectiva y mucho más opaca. 
<img src="/vc/docs/sketches/microfacets.png" alt="Roughness Theory">
Imagen__&gt;:<a href="https://learnopengl.com/PBR/Theory">https://learnopengl.com/PBR/Theory</a></p><p>  El shader PBR utiliza un canal llamado roughness que recibe un valor numérico entre 0 y 1 o una imagen en escala de grises que define este valor para diferentes zonas del material, este representa el nivel de imperfecciones microscópicas o rugosidad y lo presentará como el nivel de reflexión especular que tendrá el objeto.</p><p>  <img src="/vc/docs/sketches/img-roughness.png" alt="Roughness Implementation"></p></li><li><h4 id="canal-de-metalicidad---metallicity--metallness" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Canal de Metalicidad - Metallicity / Metallness</h4><p>Los materiales metálicos por su naturaleza conductiva tienden a reflejar rayos de luz completamente haciéndolos extremadamente especulares y en teoría por esto la mayoría de los metales tienden a no tener un color difuso específico, en la realidad propiedades como oxidación, imperfecciones e impurezas hacen que no todos los metales sean espejos perfectos. Los renderizadores PBR toman en cuenta estas propiedades con un canal llamado Metallness o Metalicidad que afecta el color base del objeto reduciendo la reflexión difusa y aumentando la especularidad, al igual que Roughness esta propiedad se mide como un valor de 0 a 1 o una imagen en escala de grises representando diferentes valores de metalicidad mapeados al objeto.
<img src="/vc/docs/sketches/img-metalness.png" alt="Diffuse Implementation"></p></li><li><h3 id="canal-normal---normal--bump--height" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Canal Normal - Normal / Bump / Height</h3><p>Este canal no está tan relacionado con las propiedades físicas de la luz sino que busca agregar pequeños detalles a la presentación de un objeto sin la necesidad de agregarlos a la malla, esto se hace para reducir la complejidad y el número de polígonos en los objetos 3D de manera que su renderización sea más óptima. La forma mas comun de representar ests detalles a a traves de un Normal Map el cual es una textura que utiliza valores RGB para codificar la posición de los detalles en XYZ afectando las normales en el cálculo de iluminación durante el render.
<img src="/vc/docs/sketches/normal.png" alt="Normal Theory">
Imagen__&gt;:<a href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping">https://learnopengl.com/Advanced-Lighting/Normal-Mapping</a>
<img src="/vc/docs/sketches/img-normal.png" alt="Diffuse Implementation"></p></li><li><h3 id="canal-de-oclusión-ambiental---ao" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Canal de Oclusión Ambiental - AO</h3><p>Finalmente el canal de Oclusión Ambiental solo se puede representar como una textura a escala de grises que define zonas en el objeto donde la luz alcanza menos y por tanto tendrán menor iluminación, esto nos permite agregar o aumentar la visibilidad de ciertos detalles que no se representan muy bien en el renderizado, de la misma manera este sirve para optimizar el proceso de renderizado al evitar realizar cálculos de oclusión ambiental por parte del renderizador.</p></li></ul><h2 id="cómo-se-procesa-esta-información" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Cómo se procesa esta información</h2><p>Inicialmente una implementación PBR debe seguir una serie de principios para procesar la información de los materiales que se presentan con los inputs de los canales mencionados anteriormente:</p><ul><li><h3 id="conservación-de-la-energía" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Conservación de la Energía</h3><p>La energía no se crea ni se destruye, solo se transforma. Este principio de la física es primordial para el procesamiento de nuestros shaders ya que una vez un rayo de luz interactúa con un material este se debe dividir en una parte que es refractada como rayos difusos y una parte que es reflejada como rayos especulares, esto quiere decir que entre mayor especularidad, menor difusión del color base del material. 
<img src="/vc/docs/sketches/energy.png" alt="Energy Conservation">
Imagen__&gt;:<a href="https://learnopengl.com/PBR/Theory">https://learnopengl.com/PBR/Theory</a></p></li><li><h3 id="aplicación-del-brdf---bidirectional-reflectance-distribution-function" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Aplicación del BRDF - Bidirectional Reflectance Distribution Function</h3><p>El BRDF es una función que actúa en el proceso de renderización, esta función toma como input el vector dirección del rayo de luz entrante Wi, el vector dirección de la vista de salida Wo (la cámara de la escena), la normal de la superficie a renderizar N y un parámetro A que se calcula con los inputs de los canales que definimos anteriormente, con esta información y siguiendo las ley de conservación de la energía el BRDF calcula la cantidad de influencia que cada rayo tiene sobre la reflexión difusa y la reflexión especular del material que generan el color de su imagen vista desde la cámara.
<img src="/vc/docs/sketches/BRDF.png" alt="BRDF">
Imagen__&gt;:<a href="https://learnopengl.com/PBR/Theory">https://learnopengl.com/PBR/Theory</a></p><p>  Existen varios modelos para implementar esta función como el modelo Lambertiano, el modelo de Bling-Phong y el modelo de Cook-Torrance, cada una de estos puede recibir más o menos parámetros obteniendo resultados diferentes y su implementación se puede hacer con diferentes ecuaciones y funciones que pueden aumentar detalles como Fresnel de las reflexiones, Oclusión Ambiental y varios cálculos extras que generan un imagen más realista pero aumentan la complejidad y el tiempo total de los cálculos a realizar.</p></li></ul><h2 id="aplicaciones-y-trucos-de-pbr-para-obtener-realismo-con-rasterización" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Aplicaciones y trucos de PBR para obtener realismo con Rasterización</h2><p>Aplicar un modelo PBR a un renderizador que utiliza Ray Tracing puede parecer intuitivo ya que la intención del PBR de modelar materiales utilizando una abstracción de sus propiedades físicas puede acoplarse muy bien a un sistema que busca modelar la luz simulando fotones, de esta manera el output del BRDF sobre la reflexión especular puede utilizarse para calcular la cantidad de iluminación indirecta ambiental que se debe utilizar en un Shader y cuyo valor exacto puede calcularse rebotando los rayos de luz en la dirección correcta, sin embargo este mismo sistema no se puede acoplar muy bien a un rasterizador que no puede calcular la iluminación global y en el cual la reflexión especular no se puede representar correctamente.</p><p>Un truco muy utilizado para obtener implementaciones de PBR utilizando un rasterizador es generando una aproximación de luz ambiental utilizando IBL (Image Based Lighting), esta luz basada en imágenes puede hacer uso de panorámicas ambientales de 360° capturadas utilizando HDRI, tambien se puede realiar un pre-render 360° de la escena para obtener incluso mas detalles de iluminacion global.</p><ul><li><h3 id="360°-hdris" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>360° HDRIs</h3><p>Este tipo de imágenes son tomadas utilizando una técnica especial que permite obtener imágenes con un rango dinámico alto lo cual les permite una mayor información sobre colores, contraste y mucho más importante para nosotros iluminacion.
<img src="/vc/docs/sketches/venice_sunset.jpg" alt="HDRI">
Imagen utilizada como fondo en ejemplos de inputs PBR anteriores (estos se realizaron en un renderizador con ray tracing)</p><p>  El tipo de imágenes HDRI que utilizamos deben ser capturadas con dispositivos especiales de captura en 360° para poder proyectarse de forma esférica alrededor de nuestra escena de manera que la pueda envolver completamente, la IBL con HDRIs es una técnica de iluminación muy utilizada también en renderizadores con ray tracing ya que nos permite obtener una excelente aproximación a luz natural, luz de ambiente y luz indirecta.</p></li><li><h3 id="360°-pre-render-baking" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>360° Pre-Render Baking</h3><p>Esta tecnica buscan crear una imagen envolvente similar al HDRI pero de la escena misma que queremos renderizar y desde el punto de vista del objeto lo cual nos permitiria implementar una aproximacion muy cercana a luz indirecta en un rasterizador, sin embargo el proceso de render en 360° para cada objeto a renderizar puede volverse mas costoso computacionalmente que el mismo Ray Tracing por lo que esta opcion no es muy utilizada.</p></li></ul><p>Una vez se obtienen estas imágenes el renderizador les aplicará diferentes máscaras de convolución de tipo blur que generar una imagen conocida como mapa de irradiación a partir de la cual se puede aproximar puntos origen de luz.
<img src="/vc/docs/sketches/irradiance.png" alt="HDRI">
Imagen__&gt;:<a href="https://avilapa.github.io/post/custom-engine-pbr/">https://avilapa.github.io/post/custom-engine-pbr/</a></p><p>Utilizando las normales a la hora de renderizar podemos calcular la proyección del HDRI que sería reflejada en el pixel que estamos renderizando y asociarlo a una convolución del HDRI según el cálculo de reflexión especular obtenida por el BRDF, esto genera una excelente aproximación de luz indirecta en nuestro renderizador por rasterizado utilizando materiales PBR.
<img src="/vc/docs/sketches/img-ibl.png" alt="IBL">
El IBL genera una aproximacion bastante buenta de iluminacion indirecta para el rasterizado pero no perfecta, notese como el renderizado por ray tracing muestra la refexion de objetos en la escena mientras que el rasterizado no puede hacer esto</p><h2 id="conclusiones" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Conclusiones</h2><ul><li>Los shaders PBR nos permiten obtener una excelente simulación de materiales y objetos con características realistas basadas en propiedades físicas comprobadas.</li><li>Su configuración con una serie de inputs estandarizados ha logrado que se generan grandes bibliotecas de shaders realistas que se pueden utilizar en diferentes aplicaciones y que no requieren gran conocimiento técnico para modificarlos y crear nuevos materiales.</li><li>Sus diferentes implementaciones pueden generar resultados relativamente similares en renderizadores basados en ray tracing o rasterización logrando una excelente aproximación al realismo en tiempo real con estos últimos. </li><li>Este tipo de materiales se han vuelto un estándar en la industria del CGI haciendo que casi todos las compañías que crean  motores de videojuegos, softwares de manipulación 3D y herramientas CAD modernas implementen Physically Based Rendering en sus productos.</li></ul><ul><li>¿Qué variaciones tienen las diferentes implementaciones de renderizadores PBR con diferentes BRDFs como Bling-Phong o Cook-Torrance?</li><li>¿Cómo se definen el resto de propiedades físicas y ópticas que afectan estas implementaciones como el fresnel y los materiales translúcidos y transparentes?</li></ul><h2 id="bibliografia" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Bibliografia</h2><ul><li>Basic Theory of Physically Based Rendering / Jeff Russell / Marmoset: 
  <a href="https://marmoset.co/posts/basic-theory-of-physically-based-rendering/">https://marmoset.co/posts/basic-theory-of-physically-based-rendering/</a></li><li>PBR Theory / Joey de Vries / LearnOpenGL: 
  <a href="https://learnopengl.com/PBR/Theory">https://learnopengl.com/PBR/Theory</a></li><li>The PBR Guide / Substance Academy: 
  <a href="https://academy.substance3d.com/courses/the-pbr-guide-part-1">https://academy.substance3d.com/courses/the-pbr-guide-part-1</a></li><li>Physically-Based Materials: Where Are We? / Sebastien Lagarde / Siggraph 2017: 
  <a href="http://openproblems.realtimerendering.com/s2017/02-PhysicallyBasedMaterialWhereAreWe.pdf">http://openproblems.realtimerendering.com/s2017/02-PhysicallyBasedMaterialWhereAreWe.pdf</a></li><li>PBR math (rasterization) / Open CASCADE Technology: 
  <a href="https://dev.opencascade.org/doc/overview/html/specification__pbr_math.html">https://dev.opencascade.org/doc/overview/html/specification__pbr_math.html</a></li><li>Custom Engine: Physically Based Rendering / Víctor Ávila:
 <a href="https://avilapa.github.io/post/custom-engine-pbr/">https://avilapa.github.io/post/custom-engine-pbr/</a></li></ul><script id="ssDZyc_JHh">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("ssDZyc_JHh", "7H5M9Vp+I8cVV99ELLvnzg==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="contentnav-0-0-16" data-no-search=""><a href="#pbr-physically-based-rendering---como-obtener-materiales-realistas-para-rasterización-y-ray-tracing" class="h1" data-content-highlight="pbr-physically-based-rendering---como-obtener-materiales-realistas-para-rasterización-y-ray-tracing">PBR (Physically Based Rendering) - Como Obtener Materiales Realistas para Rasterización y Ray Tracing</a><a href="#de-donde-nacen-los-shaders-pbr" class="h2" data-content-highlight="de-donde-nacen-los-shaders-pbr">De donde Nacen los Shaders PBR</a><a href="#que-es-pbr-y-como-se-definen-sus-inputs" class="h2" data-content-highlight="que-es-pbr-y-como-se-definen-sus-inputs">Que es PBR y como se Definen sus Inputs</a><a href="#canal-de-color---albedo--diffuse" class="h3" data-content-highlight="canal-de-color---albedo--diffuse">Canal de Color - Albedo / Diffuse</a><a href="#canal-de-rugosidad---roughness--specular" class="h3" data-content-highlight="canal-de-rugosidad---roughness--specular">Canal de Rugosidad - Roughness / Specular</a><a href="#canal-de-metalicidad---metallicity--metallness" class="h4" data-content-highlight="canal-de-metalicidad---metallicity--metallness">Canal de Metalicidad - Metallicity / Metallness</a><a href="#canal-normal---normal--bump--height" class="h3" data-content-highlight="canal-normal---normal--bump--height">Canal Normal - Normal / Bump / Height</a><a href="#canal-de-oclusión-ambiental---ao" class="h3" data-content-highlight="canal-de-oclusión-ambiental---ao">Canal de Oclusión Ambiental - AO</a><a href="#cómo-se-procesa-esta-información" class="h2" data-content-highlight="cómo-se-procesa-esta-información">Cómo se procesa esta información</a><a href="#conservación-de-la-energía" class="h3" data-content-highlight="conservación-de-la-energía">Conservación de la Energía</a><a href="#aplicación-del-brdf---bidirectional-reflectance-distribution-function" class="h3" data-content-highlight="aplicación-del-brdf---bidirectional-reflectance-distribution-function">Aplicación del BRDF - Bidirectional Reflectance Distribution Function</a><a href="#aplicaciones-y-trucos-de-pbr-para-obtener-realismo-con-rasterización" class="h2" data-content-highlight="aplicaciones-y-trucos-de-pbr-para-obtener-realismo-con-rasterización">Aplicaciones y trucos de PBR para obtener realismo con Rasterización</a><a href="#360°-hdris" class="h3" data-content-highlight="360°-hdris">360° HDRIs</a><a href="#360°-pre-render-baking" class="h3" data-content-highlight="360°-pre-render-baking">360° Pre-Render Baking</a><a href="#conclusiones" class="h2" data-content-highlight="conclusiones">Conclusiones</a><a href="#bibliografia" class="h2" data-content-highlight="bibliografia">Bibliografia</a></div></div><div id="-codedoc-toc" class="toc-0-0-13"><div class="content-0-0-14"><p><a href="/vc/">Home</a></p><div class="collapse-0-0-9 "><script id="zMlFFDHZIf">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("zMlFFDHZIf", "lqlJyab6eRMclBlk8Ftb8g==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="label" onclick="this.parentElement.classList.toggle('open')"><span class="text">Workshops</span><span class="icon-font closed">chevron_right</span></div><div class="content"><div class="collapse-0-0-9 "><script id="sAaeymShHQ">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("sAaeymShHQ", "lqlJyab6eRMclBlk8Ftb8g==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="label" onclick="this.parentElement.classList.toggle('open')"><span class="text">Imaging &amp; Video</span><span class="icon-font closed">chevron_right</span></div><div class="content"><div class="collapse-0-0-9 "><script id="ccvRTVGdfR">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("ccvRTVGdfR", "lqlJyab6eRMclBlk8Ftb8g==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="label" onclick="this.parentElement.classList.toggle('open')"><span class="text">Software</span><span class="icon-font closed">chevron_right</span></div><div class="content"><blockquote><p><a href="/vc/docs/workshops/imaging">Image</a>
<a href="/vc/docs/workshops/ascii">Mosaic</a>
<a href="/vc/docs/workshops/video">Video</a></p></blockquote></div></div><div class="collapse-0-0-9 "><script id="MxSpRxxqIZ">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("MxSpRxxqIZ", "lqlJyab6eRMclBlk8Ftb8g==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="label" onclick="this.parentElement.classList.toggle('open')"><span class="text">Hardware</span><span class="icon-font closed">chevron_right</span></div><div class="content"><blockquote><p><a href="/vc/docs/workshops/imaging-hardware">Basic</a>
<a href="/vc/docs/workshops/kernel-hardware">Kernel</a></p></blockquote></div></div></div></div><div class="collapse-0-0-9 "><script id="MaVMItPprN">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("MaVMItPprN", "lqlJyab6eRMclBlk8Ftb8g==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="label" onclick="this.parentElement.classList.toggle('open')"><span class="text">Rendering</span><span class="icon-font closed">chevron_right</span></div><div class="content"><blockquote><p><a href="/vc/docs/workshops/pbr">Research PBR</a>
<a href="/vc/docs/workshops/rendering">Implementation</a> </p></blockquote></div></div><p><a href="/vc/docs/workshops/algovis">Algovis</a>
<a href="/vc/docs/workshops/cg">Computer Graphics</a>
<a href="/vc/docs/workshops/hci">HCI</a></p></div></div><div class="collapse-0-0-9 "><script id="wbnXqOjZAW">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("wbnXqOjZAW", "lqlJyab6eRMclBlk8Ftb8g==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="label" onclick="this.parentElement.classList.toggle('open')"><span class="text">P5 Code Snippets</span><span class="icon-font closed">chevron_right</span></div><div class="content"><p><a href="/vc/docs/snippets/component">P5 Component</a>
<a href="/vc/docs/snippets/basic">Basics</a>
<a href="/vc/docs/snippets/video-dom">Video on dom</a>
<a href="/vc/docs/snippets/video-canvas">Video on canvas</a>
<a href="/vc/docs/snippets/3d">3D</a>
<a href="/vc/docs/snippets/lib">Libs</a>
<a href="/vc/docs/snippets/sound">Sound</a></p></div></div><div class="collapse-0-0-9 "><script id="MeVHnLAS_i">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("MeVHnLAS_i", "lqlJyab6eRMclBlk8Ftb8g==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="label" onclick="this.parentElement.classList.toggle('open')"><span class="text">Members</span><span class="icon-font closed">chevron_right</span></div><div class="content"><p><a href="/vc/docs/members/mauricio-meza">Mauricio Meza</a>
<a href="/vc/docs/members/afcastellanosn">Andres Castellanos</a>
<a href="/vc/docs/members/cesar-torres">Cesar Torres</a>
<a href="/vc/docs/members/luis-otalora">Luis Otálora</a>
<a href="/vc/docs/members/nn">NN</a></p></div></div></div><div class="search-0-0-15"><script id="JkOIbASmyg">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("JkOIbASmyg", "MChpnTvN8BpuKyiMGzmSYw==", {"repo":"vc","user":"graphiccuys","root":"docs/md","pick":"\\.md$","drop":"(^_)|(\\/_)"});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div></div><div class="footer-0-0-12"><div class="left"><script id="RoLeFwJOAk">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("RoLeFwJOAk", "X5W7He+ge/Kg3B6xB+T5gg==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div><div class="main"><div class="inside"><a href="https://github.com/graphiccuys/vc/" target="_blank">GitHub</a></div></div><div class="right"><script id="hpFBZOxybG">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("hpFBZOxybG", "3ehN2Qj7wHC4donAKEDe0Q==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div></div><script id="pFgcQkbstm">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("pFgcQkbstm", "bIAidu6MCPVPBcGGWLCR6Q==", {"namespace":"/vc"});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></body></html>